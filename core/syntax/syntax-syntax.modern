! Copyright (C) 2015 Doug Coleman.
! See http://factorcode.org/license.txt for BSD license.
USING: ;
IN: syntax.syntax

PARSER: ! { text } ! texts-readln ;
PARSER: " { } "  ;
PARSER: #! { text } #! texts-readln ;
PARSER: ( { } (  ;
PARSER: : { name signature body } : token parse-signature(--) body ;
PARSER: << { code } << >> parse-until ;
PARSER: <<<<<< { } <<<<<<  ;
PARSER: <<<<<<< { } <<<<<<<  ;
PARSER: <private { body } <PRIVATE PRIVATE> parse-until ;
PARSER: ====== { } ======  ;
PARSER: ======= { } =======  ;
PARSER: >>>>>> { } >>>>>>  ;
PARSER: >>>>>>> { } >>>>>>>  ;
PARSER: alias { name target } ALIAS: token parse ;
PARSER: b { } B  ;
PARSER: b { } B:  ;
PARSER: builtin { name body } BUILTIN: token body ;
PARSER: bv{ { } BV{  ;
PARSER: b{ { } B{  ;
PARSER: c { name class } C: token token ;
PARSER: char { n } CHAR: raw ;
PARSER: constant { name object } CONSTANT: token parse ;
PARSER: cs{ { } CS{  ;
PARSER: c{ { } C{  ;
PARSER: defer { name } DEFER: token ;
PARSER: error { name body } ERROR: token body ;
PARSER: exclude { name body } EXCLUDE: token => expect ; parse-until ;
PARSER: forget { name } FORGET: token ;
PARSER: from { module functions } FROM: token ; strings-until ;
PARSER: generic# { name n signature } GENERIC# token token parse-signature(--) ;
PARSER: generic { name signature } GENERIC: token parse-signature(--) ;
PARSER: hook { name symbol signature } HOOK: token token parse-signature(--) ;
PARSER: hs{ { } HS{  ;
PARSER: h{ { elements } H{ } parse-until ;
PARSER: in { name } IN: token ;
PARSER: instance { class mixin } INSTANCE: token token ;
PARSER: intersection { } INTERSECTION:  ;
PARSER: m { class name body } M: parse token body ;
PARSER: main { name } MAIN: token ;
PARSER: math { name body } MATH: token parse-signature(--) ;
PARSER: mixin { name } MIXIN: token ;
PARSER: m\ { } M\  ;
PARSER: nan { } NAN:  ;
PARSER: p" { } P"  ;
PARSER: postpone { name } POSTPONE: raw ;
PARSER: predicate { name superclass body } PREDICATE: token < expect token body ;
PARSER: primitive { name signature } PRIMITIVE: parse parse-signature(--) ;
PARSER: private> { } PRIVATE>  ;
PARSER: qualified-with { name prefix } QUALIFIED-WITH: token token ;
PARSER: qualified { name } QUALIFIED: token ;
PARSER: rename { function module name } RENAME: token token => expect token ;
PARSER: sbuf" { } SBUF"  ;
PARSER: singleton { name } SINGLETON: token ;
PARSER: singletons { names } SINGLETONS: body ;
PARSER: slot { name } SLOT: token ;
PARSER: symbol { name } SYMBOL: token ;
PARSER: symbols { names } SYMBOLS: ; parse-until ;
PARSER: syntax { name body } SYNTAX: raw body ;
PARSER: tuple { name body } TUPLE: token body ;
PARSER: t{ { } T{ case ;
PARSER: union { name strings } UNION: token body ;
PARSER: unuse { } UNUSE:  ;
PARSER: use { strings } USE: token ;
PARSER: using { strings } USING: ; strings-until ;
PARSER: v{ { elements } V{ } parse-until ;
PARSER: w{ { } W{  ;
PARSER: [ { body } [ ] parse-until ;
PARSER: \ { name } \ raw ;
PARSER: call( { signature } call( parse-signature--) ;
PARSER: call-next-method { } call-next-method  ;
PARSER: delimiter { } delimiter  ;
PARSER: deprecated { } deprecated  ;
PARSER: execute( { signature } execute( parse-signature--) ;
PARSER: f { } f  ;
PARSER: final {  } final  ;
PARSER: flushable {  } flushable  ;
PARSER: foldable {  } foldable  ;
PARSER: inline {  } inline  ;
PARSER: intersection{ { } intersection{  ;
PARSER: maybe{ { } maybe{  ;
PARSER: not{ { } not{  ;
PARSER: recursive {  } recursive  ;
PARSER: union{ { } union{  ;
PARSER: { { elements } { } parse-until ;
